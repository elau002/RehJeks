//Move check solution logic/updates out of highlight function and back into the solution check directly
  //make sure this is being called in the correct place
  //add any addition functionality (flags etc) pertaining to faceoff mode that you might want

//Decide how and when to submit answers and what should happen when a solve occurs

//display highlights generated by received text

//send text on debounced change of input

//change display on input (freeze input and display message), have button for another match, update score



angular.module('rehjeks.faceoff', [
  'ngAnimate',
  'underscore'
])
.controller('FaceoffController', function($scope, $interval, Server, $sce, $timeout, $cookies, RegexParser, $moment, Pubnub, PUBNUB, _, $state) {

  ////////////////////////
  // Internal variables
  // & functions
  ////////////////////////


  var challStartTime = new Date();

  // Logic to show "Just Start Typing" hint
  // The idea is only to show this to help new users, so if:
  //   -the user is logged in
  //   -the user has begun Typing
  //   -the user has completed two or more challenges
  //   -it's been ten seconds since the start of the problem
        // => don't show the hint
  // Otherwise, show the hint after a second if the user doesn't get the idea
  var decideToShowTypingHint = function() {
    if (window.GlobalUser.solvedChallenges.length > 1
      || $cookies.get('username')
      || $scope.attempt !== '//gi'
      || $scope.seconds >= 10) {
      return false; 
    } else if ($scope.seconds >= 2) {
      return true;
    }
  };

  // Increment timer. This is called on an $interval towards the end of this controller module.
  // Also used to trigger the "Just Start Typing" hint.
  var updateTimer = function(startTime) {
    var now = new Date();
    var secondsElapsed = Math.floor( (now - startTime) / 1000 );
    $scope.seconds = secondsElapsed % 60;
    $scope.minutes = Math.floor(secondsElapsed / 60);
    if (!$scope.minutes) {
      $scope.showHint = decideToShowTypingHint();
    }
  };   


  ////////////////////////
  // $scope variables
  ////////////////////////

  $scope.regexValid;
  $scope.attempt;
  
  // $scope.challengeData = {};
  $scope.seconds = 0;
  $scope.minutes = 0;
  $scope.showTypeHint = false;
  $scope.correctAttempt;
  $scope.otherSolutions = [];
  $scope.showAnswers = false;
  //new scope variables
  $scope.solved = false;
  $scope.solvedLocal = false;
  $scope.finalAnswer;
  //faceoffmode variables

  $scope.faceOffChallengeData = {}; //might not need, depends on if we can pass straight ot challengeData

  $scope.userScore;
  $scope.opponentName;
  $scope.opponentAttempt = '//gi';
  $scope.opponentScore;
  $scope.faceoffFinishedFlag = false;
  $scope.faceoffWonFlag = false;



  ////////////////////////
  // $scope functions
  ////////////////////////

  ////////////////////////
  // $scope functions for faceoff
  ////////////////////////
  
  

  //testing
  var func = function() { console.log($scope.attempt, $cookies.get('username')); };
  var debFunc = _.debounce(func, 300);
  var publish = function() { PUBNUB.publish({input: $scope.attempt}, $cookies.get('username')); };
  var debPublish = _.debounce(publish, 300);

  $scope.inputFaceoff = function () {
    
    console.log(PUBNUB.input.value);
    debPublish();
   
    debFunc();
    //but this should be instant
    
    $scope.checkRegex();
    if ($scope.checkSolution()) {
      $scope.finalAnswer = $scope.attempt;
      
      //run win function
      $scope.winFaceoff();
    }
  };

  $scope.getFaceoffChallenge = function() {
    $scope.faceoffChallengeData = PUBNUB.challenge.value;
  };

  $scope.leaveFaceoff = function() {
    //lose actions
    $scope.loseFaceoff();

    //end subscriptions
    PUBNUB.unsubscribe();

    //redirect
    $state.go('multiplayer');

  };

  $scope.winFaceoff = function() {
    
      //send final input
    PUBNUB.publish({input: $scope.attempt}, $cookies.get('username'));
      //send lose
    PUBNUB.publish({end: 'lose'}, $cookies.get('username'));
      //freeze input
      //reveal buttons
    $scope.faceoffFinishedFlag = true;
    $scope.faceoffWonFlag = true;
    PUBNUB.unsubscribe();
      
    //send a win to the database for the this user
    var wins = $cookies.get('wins');
    Number(wins);
    wins ++;
    $cookies.put('wins', wins);
    var score = $cookies.get('userScore');
    Number(score); 
    score ++;
    score ++;
    score ++;
    score ++;
    score ++;
    $cookies.put('userScore', score);
    Server.updateScore();

  };
  $scope.loseFaceoff = function() {
    $scope.faceoffFinishedFlag = true;
    $scope.faceoffWonFlag = false;

    

    PUBNUB.unsubscribe();

    //send loss to database for this user
    var loses = $cookies.get('loses');
    Number(loses);
    loses ++;
    $cookies.put('loses', loses);
    var score = $cookies.get('userScore');
    Number(score); 
    score --;
    score --;
    score --;
    score --;
    score --;
    $cookies.put('userScore', score);

    Server.updateScore();

  };
  $scope.highlightOpponent = function() {
    //do we need to check if Regex is valid?
    let currentOpponentRegex = RegexParser($scope.opponentAttempt);

    let opponentHighlightedText = $scope.faceoffChallengeData.text.replace(currentOpponentRegex,
      '<span class="highlighted-opponent-text">$&</span>');

    $scope.opponentHighlightedText = $sce.trustAsHtml(opponentHighlightedText);
  };

  ////////////////////////
  // $scope functions for regular challenge
  ////////////////////////


  $scope.formatTime = function(timeStr) {
    return $moment(timeStr).fromNow();
  };

  $scope.checkRegex = function() {
    valid = RegexParser($scope.attempt);
    if (valid) {
      $scope.highlight();
    }
    $scope.regexValid = true;


  };
  // Check if actual match array matches expected match array
  var solutionsMatch = function(arr1, arr2) {
    if (!arr2 || !arr1) {
      return false;
    }
    var i;   
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (i = 0; i < arr1.length; i++) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }
    return true;
  };

  $scope.checkSolution = function() {
    // Only check solution if user has input valid regex
    if ($scope.regexValid) {

      var attemptRegex = RegexParser($scope.attempt);

      // Create matches for user's input
      var userAnswers = $scope.faceoffChallengeData.text.match(attemptRegex);

      // Compare user's answers to challenge answers
      var correctSolution = solutionsMatch(userAnswers, $scope.faceoffChallengeData.expected);

      if (correctSolution) {
        $scope.correctAttempt = $scope.attempt;
        return true;
      } else {
        // Put the actual matches on the scope to regurgitate to the user in the failure fanfare box
        $scope.attemptMatch = userAnswers;
        return false;
      }

    }


  };

  $scope.highlight = function() {

    let currentRegex = RegexParser($scope.attempt);

    let highlightedText = $scope.faceoffChallengeData.text.replace(currentRegex,
      '<span class="highlighted-text">$&</span>');

    $scope.highlightedText = $sce.trustAsHtml(highlightedText);

    if ($scope.checkSolution()) {
      $scope.timeToSolve = new Date() - challStartTime;
      $scope.success = true;
      $scope.showOtherAnswers = true;
      $scope.failure = false;
    } else {
      $scope.failure = false;
    }

  };

  $scope.submit = function() {
    if ($scope.success) {
      Server.submitUserSolution($scope.correctAttempt, $scope.faceoffChallengeData.id, $scope.timeToSolve);
      window.GlobalUser.solvedChallenges.push($scope.faceoffChallengeData.id);
      $scope.success = false;
      $scope.failure = false;
      $scope.getRandom();
    } else {
      $scope.failure = true;
    }
  };

  $scope.showTime = function(timeStr) {
    return new Date(Number(timeStr)).toUTCString().slice(20, 25);
  };

  $scope.getOtherSolutions = function() {
    Server.getOtherSolutions($scope)
    .then(res => $scope.otherSolutions = res.data);
  };


  $scope.getRandom = function() {
    Server.getRandom($scope)
    .then((testString) => {
      // $scope.highlightedText = $sce.trustAsHtml(testString);
      $scope.success = false;
      $scope.failure = false;
      $scope.showAnswers = false;
      $scope.getOtherSolutions();
      $scope.$broadcast('focusOnMe');
    });
    $scope.attempt = '//gi';
    $scope.attemptMatch = undefined;
    challStartTime = new Date();
  };


  ////////////////////////
  // Run scripts!!
  ////////////////////////

  // Load Challenge
  $scope.getFaceoffChallenge();

  $scope.$watch(function() {
    console.log('digest ran');
    console.log(PUBNUB.getGameOver());
  }); 

  $scope.$watch(PUBNUB.getInput, function(newVal, oldVal) {
    $scope.opponentAttempt = newVal || '//gi';
    if ($scope.faceoffChallengeData !== undefined) {
      $scope.highlightOpponent();
    }
  });

  $scope.$watch(PUBNUB.getGameOver, function(newVal, oldVal) {
    console.log('old end', oldVal);
    console.log('new end', newVal);
    if (newVal === 'lose') {
      $scope.loseFaceoff();
    }
  });

  if ($scope.faceoffChallengeData !== undefined) { //adjust to PUBNUB for testing multi
    //test on my own with this
    $scope.highlightedText = $sce.trustAsHtml($scope.faceoffChallengeData.text);
    $scope.opponentHighlightedText = $sce.trustAsHtml($scope.faceoffChallengeData.text);

    //Get it from PUBNUB in real version below
    // $scope.faceoffChallengeData = PUBNUB.challenge;
    // $scope.highlightedText = $sce.trustAsHtml(PUBNUB.challenge);
    // $scope.opponentHighlightedText = $sce.trustAsHtml(PUBNUB.challenge);
    $scope.attempt = '//gi';
    

    // Timeout to wait until the page has fully loaded first.
    $timeout(function() {
      $scope.$broadcast('focusOnMe');
    }, 0);

  } else {
    $scope.getRandom();
  }

  // Start Timer!
  var solutionClock = $interval(function() {
    updateTimer(challStartTime);
  }, 1000);

  


})
// Custom Directive to trigger focus on the regex prompt in the correct cursor position
// Just broadcast a "focusOnMe" event in the scope to trigger this action.
.directive('focusOnMe', function() {
  return function (scope, element) {
    scope.$on('focusOnMe', function() {
      element[0].focus();
      element[0].setSelectionRange(1, 1);
    });
  };
});


